√≥
√†√£√´Wc           @   sC  d  Z  d d l Z d d l Z d d l Z d d l m Z d d l Z d d l Z e ∆í  Z d Z	 d Z
 d Z d ‚Äû  Z d ‚Äû  Z
 d	 ‚Äû  Z d
 ‚Äû  Z d ‚Äû  Z d ‚Äû  Z d
 ‚Äû  Z d ‚Äû  Z d d ‚Äû Z d ‚Äû  Z d ‚Äû  Z d ‚Äû  Z d ‚Äû  Z d ‚Äû  Z d ‚Äû  Z d ‚Äû  Z d ‚Äû  Z d ‚Äû  Z d d d ‚Äû Z d ‚Äû  Z  d ‚Äû  Z! d d ‚Äû Z" d S(   sÀú  
# ================================================================================#
#-- PROJECT NAME : Diarization package using i-vector clustering. 
#-- BACKEND : LIUM Speaker Diarization
#-- TASK : This module contains the the low level file manipulation functions

#-- Author : Sruthi.S
#-- Date : September 27th, 2016
# ================================================================================#
i√ø√ø√ø√øN(   t   VConft   1Gt   2024t   javac         C   sA   d d l  } | j |  ∆í } | j ∆í  } | j ∆í  | d | d S(   sn   Extract the duration of a wave file in sec.

    :type wavfile: string
    :param wavfile: the wave input filei√ø√ø√ø√øNi   i   (   t   wavet   opent	   getparamst   close(   t   wavfileR   t   w_filet   par(    (    s   voiceid_ilp/fm.pyt
   wave_duration   s
    
c         C   sc   g  |  D] } | j  d d ∆í ^ q } d j | ∆í } d t | ∆í d t | ∆í } t j | ∆í d S(   s√§   Take a list of waves and append them to a brend new destination wave.

    :type input_waves: list
    :param input_waves: the wave files list

    :type wavename: string
    :param wavename: the output wave file to be generatedt    s   \ s   sox N(   t   replacet   joint   strt   utilst   start_subprocess(   t   input_wavest   wavenamet   w_namest   wavest   commandline(    (    s   voiceid_ilp/fm.pyt   merge_waves&   s    
%c         C   s‚Äò   t  j j |  ∆í \ } } | d k r6 t j |  ∆í r6 nB | d k rO | d 7} n  t j d |  d d d d | d ∆í t j | d ∆í | | S(	   sh  Take any kind of video or audio and convert it to a
    "RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit,
    mono 16000 Hz" wave file using gstreamer. If you call it passing a wave it
    checks if in good format, else it converts the wave in the good format.

    :type filename: string
    :param filename: the input audio/video file to converts   .wavt   _s   gst-launch filesrc location='s>   ' ! decodebin ! audioresample ! 'audio/x-raw-int,rate=16000' !s    audioconvert !s?    'audio/x-raw-int,rate=16000,depth=16,signed=true,channels=1' !s    wavenc ! filesink location=s   .wav (   t   ost   patht   splitextR   t   is_good_waveR   t   ensure_file_exists(   t   filenamet   namet   ext(    (    s   voiceid_ilp/fm.pyt   file2wav7   s    
#c   
      C   sb  d } d } x√¨ |  D]√§ } y t  | d ∆í } Wn t t f k
 rH q n X| j d ∆í } | d k rs t d ∆í ‚Äö n  | j d ∆í } t j d | ∆í } | t | d ∆í 7} | j d	 ∆í }	 d }
 x# |	 r√¢ |
 |	 7}
 | j d	 ∆í }	 q√Ä W| |
 7} | j ∆í  q Wt j	 d | ∆í } t
 j d
 | ∆í t  | d ∆í } | j d ∆í | j | ∆í | j | ∆í | j ∆í  d S(
   s√™   Merge two or more gmm files to a single gmm file with more voice models.

    :type input_files: list
    :param input_files: the gmm file list to merge

    :type output_file: string
    :param output_file: the merged gmm output filei    t    t   rbi   t   GMMVECT_s   different kinds of models!i   s   >ii   s   echo "hello" | sudo chmod 777 t   wN(
   R   t   IOErrort   OSErrort   readt	   Exceptiont   structt   unpackt   intR   t   packR   t   systemt   write(
   t   input_filest   output_filet   num_gmmt   gmmst   ifilet	   current_ft   kindt   linet   numt   bytet	   all_othert   num_gmm_stringt   new_gmm(    (    s   voiceid_ilp/fm.pyt
   merge_gmmsN   s6    
	




c         C   s¬±   t  |  d ∆í } | j d ∆í | j d ∆í } t j d | ∆í } | d k rX t d ∆í ‚Äö n  | j d ∆í | j d ∆í t j d | j d ∆í ∆í } | j | d ∆í | j d ∆í } | S(	   si   Return gender of a given gmm file.

    :type input_file: string
    :param input_file: the gmm file
    R#   i   i   s   >ii   s   Loop needed for gmmsi    (   i   (   R   R(   R*   R+   R)   (   t
   input_filet   gmmR;   R2   t   str_lent   gender(    (    s   voiceid_ilp/fm.pyt
   get_gendery   s    


c         C   s√ò  d } |  j  d ∆í } | d k r8 t d d | ∆í ‚Äö n  |  j  d ∆í } |  j  d ∆í } |  j  t t j d | ∆í d ∆í ∆í } |  j  d ∆í } |  j  d ∆í } |  j  d ∆í } |  j  d ∆í }	 |  j  d ∆í }
 t t j d | ∆í d ∆í } | | | | | | | } | |	 |
 } d }
 | | k rqx¬† t | ∆í D]= } |
 d 7}
 | } x$ | | k  ri|
 d 7}
 | d 7} qFWq-WnR xO t | ∆í D]A } |
 d 7}
 | } x( | | d k  r¬æ|
 d 7}
 | d 7} q‚ÄîWq~W| |  j  |
 d ∆í S(	   s    Read a gaussian in binary formati    i   t   GAUSS___s   Error: the gaussian is nots    of GAUSS___ key  (%s)i   s   >ii   (   R(   R)   R,   R*   R+   t   range(   t   g_filet   fullt   g_keyt   g_idt   g_lengtht   g_namet   g_gendert   g_kindt   g_dimt   g_countt   g_weightt	   dimensiont   g_headert   datasizet   jayt   tee(    (    s   voiceid_ilp/fm.pyt   _read_gaussian‚Äò   s>    %



c         C   s≈í   |  j  d ∆í } | d k r2 t d d | ∆í ‚Äö n  |  j  d ∆í } | | } x: t t t j d | ∆í d ∆í ∆í D] } | t |  ∆í 7} qn W| S(   s,   Read a gaussian container in a binary formati   t   GAUSSVECs   Error: the gaussian containers    is not of GAUSSVEC kind %si   s   >ii    (   R(   R)   RD   R,   R*   R+   RU   (   RE   t   chkt   gcst   stufft   index(    (    s   voiceid_ilp/fm.pyt   _read_gaussian_container¬µ   s    
)c         C   s√π   i  } |  j  d ∆í } | d k r0 t d ∆í ‚Äö n  |  j  d ∆í } |  j  d ∆í } |  j  t t j d | ∆í d ∆í ∆í } | | d <|  j  d ∆í } |  j  d ∆í } |  j  d ∆í } |  j  d ∆í }	 | | | | | | | |	 }
 |
 | d	 <t |  ∆í | d
 <| S(   s   Read a gmm in a binary formati   t   GMM_____s.   Error: Gmm section doesn't match GMM_____ kindi   s   >ii    R   i   t   headert   content(   R(   R)   R,   R*   R+   R[   (   RE   t   myfileR6   t   hash_t   lengthR   t   gent   gausskt   dimt   compt   gvect_header(    (    s   voiceid_ilp/fm.pyt	   _read_gmm√Ñ   s     %
"
c         C   se  t  |  d ∆í } | j d ∆í } | d k r9 t d ∆í ‚Äö n  | j d ∆í } t t j d | ∆í d ∆í } | t j d d ∆í } g  } x' t | ∆í D] } | j t	 | ∆í ∆í q¬ç W| j
 ∆í  |  d	  } d }	 t j j
 | ∆í \ }
 } | d k ra| }
 xp | D]e } t j j |
 d
 | |	 f ∆í } t  | d ∆í }
 |
 j | | d | d
 ∆í |
 j
 ∆í  |	 d 7}	 q√µ Wn  d S(   s  Split a gmm file into gmm files with a single voice model.

    :type input_file: string
    :param input_file: the gmm file containing various voice models

    :type output_dir: string
    :param output_dir: the directory where is splitted the gmm input fileR#   i   R$   s   Error: Not a GMMVECT_ file!i   s   >ii    i   i√º√ø√ø√øs
   %s%04d.gmmR%   R]   R^   N(   R   R(   R)   R,   R*   R+   R-   RD   t   appendRg   R   R   R   t   splitt   NoneR   R/   (   R>   t
   output_dirRE   t   keyt   sizeR8   t   main_headert   filest
   file_basenameRZ   t   basedirR   t   newnamet   gmm_f(    (    s   voiceid_ilp/fm.pyt	   split_gmm√ö   s,    




c   
      C   sP  t  |  d ∆í } t  |  d d ∆í } | j d ∆í } | j | ∆í | j d ∆í } t j d | ∆í } | d k rz t d ∆í ‚Äö n  | j | ∆í | j d ∆í } | j | ∆í | j d ∆í } | j | ∆í t j d | j d ∆í ∆í }	 | j |	 d	 ∆í }
 t j d t | ∆í ∆í } | j | ∆í | j | ∆í | j ∆í  } | j | ∆í | j ∆í  | j ∆í  d
 S(   s√©   Rename a gmm with a new speaker identifier(name) associated.

    :type input_file: string
    :param input_file: the gmm file to rename

    :type identifier: string
    :param identifier: the new name or identifier of the gmm modelR#   s   .newR%   i   i   s   >ii   s   Loop needed for gmmsi    N(   i   (	   R   R(   R/   R*   R+   R)   R-   t   lenR   (
   R>   t
   identifierR?   R<   R6   R;   R2   t   gmm_1t   nothingR@   R   t   new_lenR:   (    (    s   voiceid_ilp/fm.pyt
   rename_gmm√Ω   s,    







c         C   s/   t  |  ∆í t |  | ∆í t |  ∆í t |  ∆í d S(   s  Build a gmm (Gaussian Mixture Model) file from a given wave with a
    speaker identifier  associated.

    :type filebasename: string
    :param filebasename: the input file basename

    :type identifier: string
    :param identifier: the name or identifier of the speakerN(   t   diarization_standardt	   ident_segt   _train_initt
   _train_map(   t   filebasenameRv   (    (    s   voiceid_ilp/fm.pyt	   build_gmm  s    



c      	   C   sI  |  d } t  | d ∆í } x| j ∆í  D]} | j d ∆í s& | j ∆í  } | d } t | d ∆í d } t | d ∆í d } y& t j j |  | ∆í } t j | ∆í Wn1 t j	 k
 r√í }	 |	 j
 d k r√Ü q√ì t j	 ‚Äö n Xt j j |  | d	 | t | ∆í t | ∆í f ∆í }
 d
 |  |
 | | f } t j
 | ∆í t j |
 ∆í q& q& W| j ∆í  d S(   s√£   Take a wave and splits it in small waves in this directory structure
    <file base name>/<cluster>/<cluster>_<start time>.wav

    :type filebasename: string
    :param filebasename: filebasename of the seg and wav input filess
   .ev_is.segt   rs   ;;i   i   id   i   i   s   %s_%07d.%07d.wavs   sox %s.wav %s trim  %s %sN(   R   t	   readlinest
   startswithRi   t   floatR   R   R   t   makedirst   errort   errnoR,   R   R   R   R   (   R   t   segfilet   segR7   t   arrt   clustt   startt   endt   mydirt   errt	   wave_pathR   (    (    s   voiceid_ilp/fm.pyt   seg2trim+  s0    




c         C   s  d ‚Äû  } t  j j |  ∆í d } t |  d ∆í } g  } x? | j ∆í  D]1 } | j d ∆í sA | j ∆í  } | j | ∆í qA qA W| j ∆í  | j	 d | d t
 ∆í | d } t | d ∆í } d }	 x¬® | D]¬† } |	 d	 }	 t | d
 ∆í d }
 |
 t | d ∆í d } | j t
 |	 ∆í d
 ∆í | j t j |
 ∆í d t j | ∆í d
 ∆í | j | d d
 ∆í | j d
 ∆í q¬º W| j ∆í  t j | d ∆í d S(   sÀÜ   Take a seg file and convert it in a subtitle file (srt).

    :type segfile: string
    :param segfile: the segmentation file to convertc         S   s   t  |  d ∆í S(   s1   Help function for sort, to extract time from linei   (   R,   (   t   aline(    (    s   voiceid_ilp/fm.pyt   readtimeR  s    i    R¬Å   s   ;;Rl   t   reverses   .srtR%   i   i   id   i   s   
s    --> i   N(   R   R   R   R   R‚Äö   R∆í   Ri   Rh   R   t   sortt   FalseR‚Äû   R/   R   R   t
   humanize_timeR   (   RÀÜ   R‚Äú   t   basenameR‚Ä∞   t   linesR7   R≈†   t
   fileoutputt   srtfilet   rowR≈í   R¬ç   (    (    s   voiceid_ilp/fm.pyt   seg2srtM  s0    	



%
c         C   s   t  |  | |  d ∆í d S(   s_   Substitute cluster names with speaker names ang generate a
    "<filebasename>.ident.seg" file.s   .identN(   t   ident_seg_rename(   R   Rv   (    (    s   voiceid_ilp/fm.pyR|   n  s    c   
      C   s  t  |  d d ∆í } g  } | j ∆í  } xW | D]O } xF | j ∆í  D]8 } | j d ∆í r? | j d ∆í d } | j | ∆í q? q? Wq, W| j ∆í  t  | d d ∆í }	 | j ∆í  x> | D]6 } x  | D] } | j | | ∆í } q¬∫ W|	 j | ∆í q¬≠ W|	 j ∆í  t	 j
 | d ∆í d S(   sP   Take a seg file and substitute the clusters with a given name or
    identifier.s   .segR¬Å   s   cluster:t   :i   R%   N(   R   R‚Äö   Ri   R∆í   Rh   R   R‚Äù   R
   R/   R   R   (
   R   Rv   t
   outputnamet   seg_ft   clustersR‚Ñ¢   R7   Rl   t   clut   output(    (    s   voiceid_ilp/fm.pyR≈æ   t  s"    





c         C   s¬ù   d ‚Äû  } t  |  d ∆í } | j ∆í  } | j ∆í  t t d ‚Äû  | j ∆í  ∆í ∆í } | | | ∆í } |  d } t  | d ∆í } | j | ∆í | j ∆í  t j | ∆í d S(   s6   Substitute cluster names with real names in subtitles.c            sC   t  j d j t t  j ÀÜ  ∆í ∆í ∆í } ‚Ä°  f d ‚Ä†  } | j | |  ∆í S(   sy   Take a text and replace words that match a key in a dictionary with
        the associated value, return the changed textt   |c            s   ÀÜ  |  j  d ∆í d S(   s   not documentedi    s   
(   t   group(   t   match(   t   word_dic(    s   voiceid_ilp/fm.pyt	   translate‚Äò  s    (   t   ret   compileR   t   mapt   escapet   sub(   t   textR¬®   t   recR¬©   (    (   R¬®   s   voiceid_ilp/fm.pyt
   replace_words≈í  s    $s   .srtc         S   s    |  \ } } t  | ∆í d | f S(   Ns   
(   R   (   t   .0Rl   t   value(    (    s   voiceid_ilp/fm.pyt   <lambda>≈°  s    s
   .ident.srtR%   N(	   R   R(   R   t   dictR¬¨   t   itemsR/   R   R   (   R   t	   key_valueR¬±   t   file_original_subtitlet   original_subtitleR¬Ø   t   out_filet   fout(    (    s   voiceid_ilp/fm.pyt   srt2subnames‚Ä∞  s    	



c         C   sk   t  j s d GHn  t |  ∆í t j j |  ∆í d } t  j sB d GHn  t | ∆í t  j s] d GHn  t | ∆í d S(   s¬≥   Take a video or audio file and converts it into smaller waves according
    to the diarization process.

    :type filename: string
    :param filename: the input file audio/videos   *** converting video to wav ***i    s   *** diarization ***s   *** trim ***N(   t
   CONFIGURATIONt
   QUIET_MODER!   R   R   R   t   diarizationR‚Äò   (   R   Rp   (    (    s   voiceid_ilp/fm.pyt	   file2trim¬§  s    	
	
	c         C   sA   t  j t d t d t j d d |  ∆í t  j |  d ∆í d S(   s√¥   Take a wave file in the correct format and build a segmentation file.
    The seg file shows how much speakers are in the audio and when they talk.

    :type filebasename: string
    :param filebasename: the basename of the wav file to processs    -Xmxs    -jar s+    fr.lium.spkDiarization.system.Diarization s>   --fInputMask=./%s.wav --sOutputMask=./%s.seg --doCEClustering s   .segN(   R   R   t   JAVA_EXEt	   JAVA_MEM1R¬Ω   t   LIUM_JARR   (   R   (    (    s   voiceid_ilp/fm.pyR{   ¬∂  s    &t   3t   75c         C   s‚Ä¶  d } d } d } d } d } t  j j |  ∆í s@ t  j |  ∆í n  d GHt j t d t d t j	 d	 d
 | d | d |  ∆í t j
 |  d
 ∆í d GHt j t d t d t j	 d d | d |  ∆í t j
 |  d ∆í d GHt j t d t d t j	 d d d | d d |  ∆í t j
 |  d ∆í d GHd } t j t d t d t j	 d d | d d | d |  ∆í t j
 |  d ∆í d  GHt j t d t d t j	 d d | d! d" | d |  ∆í t j
 |  d# ∆í d$ GHt j t d t d t j	 d% d& d | d' d( |  ∆í t j
 |  d) ∆í d* GHt j t d t d t j	 d+ d& d | d' d, |  ∆í t j
 |  d- ∆í d. GHt j t d t d t j	 d/ d | d0 d1 |  ∆í t j
 |  d2 ∆í d3 GHt j t d t d t j	 d/ d | d4 d5 d6 t j d |  ∆í t j
 |  d7 ∆í d8 GHt j t d t d t j	 d9 d | d4 d: d; d< |  ∆í t j
 |  d= ∆í d> GHt j t d t d t j	 d? d@ | dA dB t j d |  ∆í t j
 |  dC ∆í dD GHt j t d t d t j	 dE dF | dG d | dH dI dJ dK dL dM |  ∆í t j
 |  dN ∆í t j
 s¬Åt  j |  ∆í }	 x |	 D] }
 t  j |
 ∆í qgWn  d  S(O   Ns&   audio16kHz2sphinx,1:1:0:0:0:0,13,0:0:0s   sphinx,1:1:0:0:0:0,13,0:0:0s   sphinx,1:3:2:0:0:0,13,0:0:0:0s   sphinx,1:3:2:0:0:0,13,1:1:0:0s   sphinx,1:3:2:0:0:0,13,1:1:300:4s   compute the MFCCs    -Xmxs    -classpath s5    fr.lium.spkDiarization.tools.Wave2FeatureSet --help s!   --fInputMask=%s.wav --fInputDesc=s%    --fOutputMask=%s.mfcc --fOutputDesc=R   s   .mfccs   check the MFCCs3    fr.lium.spkDiarization.programs.MSegInit   --help s"   --fInputMask=%s.mfcc --fInputDesc=s&    --sInputMask= --sOutputMask=%s.i.seg s   .i.segs+   GLR based segmentation, make small segmentss2    fr.lium.spkDiarization.programs.MSeg --kind=FULL s+   --sMethod=GLR  --help --fInputMask=%s.mfcc s
   --fInputDesc=s    --sInputMask=%s.i.seg s   --sOutputMask=%s.s.seg s   .s.segs   Segmentation: linear clusteringt   2s/    fr.lium.spkDiarization.programs.MClust --help s.    --sInputMask=%s.s.seg --sOutputMask=%s.l.seg s   --cMethod=l --cThr=s   .l.segs   hierarchical clusterings.    --sInputMask=%s.l.seg --sOutputMask=%s.h.seg s    --cMethod=h --cThr=s   .h.segs   initialize GMMs3    fr.lium.spkDiarization.programs.MTrainInit --help s,   --nbComp=8 --kind=DIAG --fInputMask=%s.mfcc s    --sInputMask=%s.h.seg s   --tOutputMask=%s.init.gmms s
   .init.gmmss   EM computations1    fr.lium.spkDiarization.programs.MTrainEM --help s0   --tOutputMask=%s.gmms --tInputMask=%s.init.gmms s   .gmmss   Viterbi decodings0    fr.lium.spkDiarization.programs.MDecode --help s.    --sInputMask=%s.h.seg --sOutputMask=%s.d.seg s%   --dPenality=250 --tInputMask=%s.gmms s   .d.segs!   Speech/Music/Silence segmentations    --fInputMask=%s.mfcc s/   --sInputMask=%s.i.seg --sOutputMask=%s.pms.seg s"   --dPenality=10,10,50 --tInputMask=s   .pms.segs2   filter spk segmentation according pms segmentations-    fr.lium.spkDiarization.tools.SFilter --help sE   --fltSegMinLenSpeech=150 --fltSegMinLenSil=25 --sFilterClusterName=j sB   --fltSegPadding=25 --sFilterMask=%s.pms.seg --sInputMask=%s.d.seg s   --sOutputMask=%s.flt.seg s   .flt.segs   Set gender and bandwiths/    fr.lium.spkDiarization.programs.MScore --help s$   --sGender --sByCluster --fInputDesc=s.    --fInputMask=%s.mfcc --sInputMask=%s.flt.seg s$   --sOutputMask=%s.g.seg --tInputMask=s   .g.segs   ILP ClusteringsG    fr.lium.spkDiarization.programs.ivector.ILPClustering --cMethod=es_iv s	   --ilpThr=s9    --help --sInputMask=%s.g.seg --sOutputMask=%s.ev_is.seg s    --tInputMask=./ubm/wld.gmm s5   --nEFRMask=mat/wld.efn.xml --ilpGLPSolProgram=glpsol s7   --nMahanalobisCovarianceMask=./mat/wld.mahanalobis.mat s0   --tvTotalVariabilityMatrixMask=./mat/wld.tv.mat s*   --ilpOutputProblemMask=%s.ilp.problem.txt s,   --ilpOutputSolutionMask=%s.ilp.solution.txt s
   .ev_is.seg(   R   R   t   isdirt   mkdirR   R   R√Å   R√Ç   R¬Ω   R√É   R   t   SMS_GMMSt   GENDER_GMMSt   KEEP_INTERMEDIATE_FILESt   listdirt   remove(   R   t   ht   ct
   fDescStartt   fDesct   fDescDt	   fDescLastt   fDescCLRt   lt   f_listR    (    (    s   voiceid_ilp/fm.pyR¬ø   √Ü  sx    6.6::662A:=	N	
c         C   sT   t  j t d t d t j d d d d t j d |  ∆í t  j |  d ∆í d	 S(
   s$   Train the initial speaker gmm model.s    -Xmxs   m -cp s3    fr.lium.spkDiarization.programs.MTrainInit --help s.   --sInputMask=%s.ident.seg --fInputMask=%s.wav s:   --fInputDesc="audio16kHz2sphinx,1:3:2:0:0:0,13,1:1:300:4" s!   --emInitMethod=copy --tInputMask=s    --tOutputMask=%s.init.gmm s	   .init.gmmN(   R   R   R√Å   t	   JAVA_MEM2R¬Ω   R√É   t   UBM_PATHR   (   R   (    (    s   voiceid_ilp/fm.pyR}   e  s    9c         C   s<   t  j t d t d t j d d d d d |  ∆í d S(	   s6   Train the speaker model using a MAP adaptation method.s    -Xmxs   m -cp s2    fr.lium.spkDiarization.programs.MTrainMAP --help s.   --sInputMask=%s.ident.seg --fInputMask=%s.wav s:   --fInputDesc="audio16kHz2sphinx,1:3:2:0:0:0,13,1:1:300:4" s?   --tInputMask=%s.init.gmm --emCtrl=1,5,0.01 --varCtrl=0.01,10.0 s   --tOutputMask=%s.gmm N(   R   R   R√Å   R√ó   R¬Ω   R√É   (   R   (    (    s   voiceid_ilp/fm.pyR~   q  s    c         C   s√ä   t  j } | d k r | } n  t j j | ∆í d } d G| GHd G| GHt j d t d t  j	 d d | d | d	 d
 | d | d | d t  j
 d
 |  ∆í t j |  d | d | d ∆í d S(   s√¨  Match a wav file and a given gmm model file and produce a segmentation
    file containing the score obtained.

    :type filebasename: string
    :param filebasename: the basename of the wav file to process

    :type gmm_file: string
    :param gmm_file: the path of the gmm file containing the voice model

    :type gender: char
    :param gender: F, M or U, the gender of the voice model

    :type custom_db_dir: None or string
    :param custom_db_dir: the voice models database to usei   t   databaset   gmm_names   echo "hello" | sudo -S s    -Xmx256M -cp sB    fr.lium.spkDiarization.programs.MScore --sInputMask=%s.ev_is.seg s+   --fInputMask=%s.wav --sOutputMask=%s.ident.t   .s$   .ev_is.seg --sOutputFormat=seg,UTF8 s@   --fInputDesc=audio2sphinx,1:3:2:0:0:0,13,1:0:300:4 --tInputMask=t   /s
    --sTop=8,s    --sSetLabel=add --sByCluster s   .ident.s
   .ev_is.segN(   R¬Ω   t   DB_DIRRj   R   R   Ri   R   R   R√Å   R√É   R√ò   R   (   R   t   gmm_fileRA   t
   custom_db_dirR√ô   R√ö   (    (    s   voiceid_ilp/fm.pyt
   wav_vs_gmm{  s    				Y(#   t   __doc__R   R¬™   R*   t   __init__R    R   t   sysR¬Ω   R√Ç   R√ó   R√Å   R   R   R!   R=   RB   RU   R[   Rg   Rj   Rt   Rz   R‚Ç¨   R‚Äò   R¬ù   R|   R≈æ   R¬º   R√Ä   R{   R¬ø   R}   R~   R√†   (    (    (    s   voiceid_ilp/fm.pyt   <module>   s@   					+		$		#			"	!					≈∏		
